"use strict";
/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assistant_1 = require("../../assistant");
const common_1 = require("../../common");
const conv_1 = require("./conv");
const isVerification = (verification) => typeof verification.headers === 'object';
/** @public */
exports.dialogflow = (options = {}) => assistant_1.attach({
    handlers: {
        intents: {},
        catcher: (conv, e) => {
            throw e;
        },
    },
    middlewares: [],
    intent(intent, handler) {
        this.handlers.intents[intent] = handler;
        return this;
    },
    catch(catcher) {
        this.handlers.catcher = catcher;
        return this;
    },
    fallback(handler) {
        this.handlers.fallback = handler;
        return this;
    },
    middleware(middleware) {
        this.middlewares.push(middleware);
        return this;
    },
    init: options.init,
    verification: options.verification,
    handler(body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const { debug, init, verification } = this;
            if (verification) {
                const { headers: verificationHeaders, status = 403, error = (e) => e, } = isVerification(verification) ? verification :
                    { headers: verification };
                for (const key in verification) {
                    const check = headers[key.toLowerCase()];
                    if (!check) {
                        return {
                            status,
                            body: {
                                error: typeof error === 'string' ? error :
                                    error('A verification header key was not found'),
                            },
                        };
                    }
                    const value = verificationHeaders[key];
                    const checking = common_1.toArray(check);
                    if (checking.indexOf(value) < 0) {
                        return {
                            status,
                            body: {
                                error: typeof error === 'string' ? error :
                                    error('A verification header value was invalid'),
                            },
                        };
                    }
                }
            }
            let conv = new conv_1.DialogflowConversation({
                body,
                headers,
                init: init && init(),
                debug,
            });
            for (const middleware of this.middlewares) {
                conv = middleware(conv)
                    || conv;
            }
            const { intent } = conv;
            const traversed = {};
            let handler = intent;
            while (typeof handler !== 'function') {
                if (typeof handler === 'undefined') {
                    if (!this.handlers.fallback) {
                        throw new Error(`Dialogflow IntentHandler not found for intent: ${intent}`);
                    }
                    handler = this.handlers.fallback;
                    continue;
                }
                if (traversed[handler]) {
                    throw new Error(`Circular intent map detected: "${handler}" traversed twice`);
                }
                traversed[handler] = true;
                handler = this.handlers.intents[handler];
            }
            try {
                yield handler(conv, conv.parameters, conv.arguments.parsed.list[0], conv.arguments.status.list[0]);
            }
            catch (e) {
                yield this.handlers.catcher(conv, e);
            }
            return {
                status: 200,
                body: conv.serialize(),
            };
        });
    },
}, options);
//# sourceMappingURL=dialogflow.js.map